# fs

## Общие моменты

Пишем приложения под Ubuntu.

Можно на C++, только не надо усложнять код. Фокус на том, чтобы разобраться в файловой системе, а не
в ОО-дизайне.

Хотим поразбираться в файловой системе ext. Чтобы вынести за скобки журналирование, ориентируемся на ext2.

Для тестов можно и нужно создать обычный файл и использовать его вместо файла-устройства.

Для выполнения заданий могут потребоваться структуры, размер которых пропорционален размеру устройства.

Если ваш код будет работать на тестовом файле-устройстве размером условно 1G и падать по памяти на реальном разделе
размером условно 1T - это не считается проблемой. В реальных продуктовых аналогах с этим надо было бы что-то делать,
но мы здесь не про классические структуры данных.

Если вы хотите запушить работу вместе со своими тестами, это приветствуется, но не надо пушить тестовые образы диска.
Лучше запушьте скрипты, которые их создают и, возможно, инструкцию по запуску.

## Задание 1

2 балла

Напишите утилиту bgdump (block group dump).

Она должна принимать имя файла-устройства и номер группы блоков.

Например:

```
bgdump dev-file-name 123
```

Если файл не отформатирован под ext2 или номер группы блоков не корректен, напечатайте адекватное сообщение об ошибке.

Если это ext2 и номер группы блоков, напечатайте визуализацию ее содержимого.

Она должна состоять из двух частей:

- визуализация inode-ов
- визуализация блоков

### Визуализация inode-ов

Каждый тип inode-да будем отражать отдельной буквой. Если inode не используется файловой системой, обозначим его буквой X.
Если inode используется под обычный файл, назовем его R. Обозначения остальных типов - на ваше усмотрение.

На каждой строчке разместим статус 64 inode-ов. 

В начале строчки - 16-ричный номер начального inode-а данной строки. Без 0x в начале, выровненный на 6 позиций с ведущими нулями и пробелом справа.

Потом пробел и 8 позиций с визуализацией 8 inode-ов, и так 8 раз.

Как-то так:

```
000000  XXXAGRXX 12345678 ABCDEFGH AABBCCDD 11223344 AAAABBBB BBBBAAAA XXXXXXXX AAAAAAAA
000040  12345678 ABCDEFGH AABBCCDD 11223344 AAAABBBB BBBBAAAA XXXXXXXX AAAAAAAA BBBBBBBB
...
```

### Визуализация блоков

Визуализация блоков крупным планом будет напоминать визуализацию inode-ов, но она будет
немного более подробной, поэтому в строке влезет меньше элементов.

Для каждого блока хотим видеть, используется он или нет.

Если он используется для данных обычного файла, то хотим видеть что-то такое: `R-001234:0000A5`.

Это означает, что данный блок используется в inode 0x1234 и его порядковый номер - 0xA5. То есть начало этого блока
соответствует смещению 85 * block_size в файле.

Если это другие типы inode-ов, надо использовать столько же байтов, буква должна соответствовать типу inode-а, первое
число - его номеру, а то, что после двоеточия - придамайте, какое полезное знание туда поместить. Если  не придумывается -
поместите пробелы. Важно, чтобы на смеси типов в итоге получалась визуальная табличка и границы столбцов были ровными.

Некоторые блоки могут не принадлежать inode-ам, но при этом использоваться файловой системой.
Для них придумайте свою нотацию, чтобы в то же число символов уложиться и какое-то знание донести до пользователя.

Тут получается по 4 блока на строку.

Тут есть небольшой резерв для расширения столбцов. Его можно использовать при необходимости, только не ломать выравнивание.

То есть сейчас для обычного файла используется 15 символов, а вам может захотеться для другого типа использовать 18, но тогда
надо данные обычного файла пробелами дополнить.

