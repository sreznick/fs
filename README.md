# Файловые системы

## Общие моменты

Пишем приложения под Ubuntu.

Можно на C++, только не надо усложнять код. Фокус на том, чтобы разобраться в файловой системе, а не
в ОО-дизайне.

Можно и на Go. Только это должны быть ваша работа с байтами. Не найти библиотеку, которая все сделает.
(К C/C++ это тоже относится, но там и барьер к такому варианту изначально повыше - и такой вариант реже
в голову не приходит).

Хотим поразбираться в файловой системе ext. Чтобы вынести за скобки журналирование, ориентируемся на ext2.

Для тестов можно и нужно создать обычный файл и использовать его вместо файла-устройства.

Для выполнения заданий могут потребоваться структуры, размер которых пропорционален размеру устройства.

Если ваш код будет работать на тестовом файле-устройстве размером условно 1G и падать по памяти на реальном разделе
размером условно 1T - это не считается проблемой. В реальных продуктовых аналогах с этим надо было бы что-то делать,
но мы здесь не про классические структуры данных.

Если вы хотите запушить работу вместе со своими тестами, это приветствуется, но не надо пушить тестовые образы диска.
Лучше запушьте скрипты, которые их создают и, возможно, инструкцию по запуску.

## Баллы

Сумма баллов - 14.

Это так и задумано. В значенателе будет 10. То есть можно сделать не все. Или сделать избыточно и получить бонусы,
которые войдут в общую сумму.

## Задание 1: Визуализация группы блоков

3 балла

Напишите утилиту bgdump (block group dump).

Она должна принимать имя файла-устройства и номер группы блоков.

Например:

```
bgdump dev-file-name 123
```

Если файл не отформатирован под ext2 или номер группы блоков не корректен, напечатайте адекватное сообщение об ошибке.

Если это ext2 и номер группы блоков, напечатайте визуализацию ее содержимого.

Она должна состоять из двух частей:

- визуализация inode-ов
- визуализация блоков

### Визуализация inode-ов

Каждый тип inode-да будем отражать отдельной буквой. Если inode не используется файловой системой, обозначим его буквой X.
Если inode используется под обычный файл, назовем его R. Обозначения остальных типов - на ваше усмотрение.

На каждой строчке разместим статус 64 inode-ов. 

В начале строчки - 16-ричный номер начального inode-а данной строки. Без 0x в начале, выровненный на 6 позиций с ведущими нулями и пробелом справа.

Потом пробел и 8 позиций с визуализацией 8 inode-ов, и так 8 раз.

Как-то так:

```
000000  XXXAGRXX 12345678 ABCDEFGH AABBCCDD 11223344 AAAABBBB BBBBAAAA XXXXXXXX AAAAAAAA
000040  12345678 ABCDEFGH AABBCCDD 11223344 AAAABBBB BBBBAAAA XXXXXXXX AAAAAAAA BBBBBBBB
...
```

### Визуализация блоков

Визуализация блоков крупным планом будет напоминать визуализацию inode-ов, но она будет
немного более подробной, поэтому в строке влезет меньше элементов.

Для каждого блока хотим видеть, используется он или нет.

Если он используется для данных обычного файла, то хотим видеть что-то такое: `R-001234:0000A5`.

Это означает, что данный блок используется в inode 0x1234 и его порядковый номер - 0xA5. То есть начало этого блока
соответствует смещению 85 * block_size в файле.

Если это другие типы inode-ов, надо использовать столько же байтов, буква должна соответствовать типу inode-а, первое
число - его номеру, а то, что после двоеточия - придамайте, какое полезное знание туда поместить. Если  не придумывается -
поместите пробелы. Важно, чтобы на смеси типов в итоге получалась визуальная табличка и границы столбцов были ровными.

Некоторые блоки могут не принадлежать inode-ам, но при этом использоваться файловой системой.
Для них придумайте свою нотацию, чтобы в то же число символов уложиться и какое-то знание донести до пользователя.

Тут получается по 4 блока на строку.

Тут есть небольшой резерв для расширения столбцов. Его можно использовать при необходимости, только не ломать выравнивание.

То есть сейчас для обычного файла используется 15 символов, а вам может захотеться для другого типа использовать 18, но тогда
надо данные обычного файла пробелами дополнить.

## Задание 2: Восстановление файла: ситуация попроще

3 балла

На файловой системе ext2 случайно удален нужный файл. Сразу после удаления человек опомнился и размонтировал файловую систему.
Другие процессы с интенсивной записью в момент удаления не работали.

Напишите утилиту, которая "вернет" такой файл на место.

Утилита должна работать с несмонтированным файлом-устройством. 

```
recover-ext2 device-file file-to-recover
```

Если файл не удален, это надо понять и сообщить (не монтируя).

Если признаков наличия такого файла не найдено, надо об этом сообщить.

А если смогли найти - восстановить. Если просто удался файл и больше ничего не делалось - должны смочь.


## Задание 3: Восстановление файла: ситуация посложнее

3 балла

Баллов столько же, сколько за попроще, потому что мы тут все не собираемся делать end-to-end решение. Только фрагнмент.

Ситуация посложеннее - это ситуация  высокой вероятности того, что какие-то элементы удаленного файла уже используются другими файлами.
Или мы удалили каталог на 3-4 уровня выше нашего файла.

Но иногда в таких ситуацмях можно бороться. Особенно если даже фрагментарное восстановление может быть полезным.

Один из вариантов борьбы - искать среди свободных блоков те, содержимое которых выглядит как содержимое восстанавливаемого файла.
Также можно найти среди свободных блок, содержимое которого выглядит как содержимое блока косвенной адресаций. А если в нем окажется ссылка на блок файла, то так можно узнать и адреса других блоков. Какие-то из них могут оказаться все еще свободными и мы сможем восстановить
хотя бы их. Иногда это может помочь.

Все это реализовывать мы не будем. Реализуем только своего рода `grep` по свободным блокам. Поэтому назовем утилиту `grepfb-ext2`.

Запуск:

```
grepfb-ext2 pattern device-file
```

Выводим номера свободных блоков, в которых нашелся указанный шаблон. Шаблон понимаем как просто строчку.
Ситуации попадания шаблона на границу блоков не рассматриваем.



## Задание 4: Дефрагментация с логированием

5 баллов

### Введение

Дефрагментация может быть очень простой задачей, если у вас есть пустой диск: скопировали файлы на новый диск,
переформатировали старый, скопировали обратно.

Но не всегда этот диск есть.

Если у вас занято 800G из 1024G и надо дефрагментировать и других 800G у вас под рукой нет - тут посложнее.

Конкретный алгоритм может зависеть от приоритетов. Но многие варианты в конечном итоге могут сводиться к последовательности
swap-ов.

То есть мы решаем, что конкретный блок конкретного файла надо перенести в конкретное место, но в этом месте уже живет другой блок.
И мы их просто поменяем местами.

Такое сведение дефрагментации к последовательности `swap`-ов несет в себе как плюсы, так и минусы.

Плюсом является то, что в такой схеме проще организовать логирование для борьбы с отключением питания. Потому что каждый swap - маленькая атомарная операция.

### Содержание задания

Итак, в рамках задания предлагается предлагается организовать утилиту атомарного swap-а блоков:

```
swapblocks device-file log-file actions-file
```

`device-file` - не смонтированный файл-устройство

`log-file` - лог операций для обеспечения атомарности

`actions-file` - файл, описывающмй последовательность swap-ов

### Файлы

Все три файла - файлы из контекста текущей VFS.

Гарантируется, что `device-file` и `actions-file` существуют и являются обычными файлами.

`log-file` мржет не существовать. Но если он существует, то гарантируется, что это обычный файл.

`actions-file` состоит из строк.

Гарантируется, что в каждой строке хранятся два числа. Например:

```
123 543
```

Числа задают номера блоков.

Чтобы не умножать число ветвлений, гарантируется, что каждое число - номер свободного блока
или номер блока, принадлежащего обычному файлу.

Менять местами два свободных блока боьшого смысла нет. Будем считать такую ситуацию формально не запрещенной,
но такую строчку просто пропускаем, ничего не делаем.

Аналогично поступаем в случае `swap`-а двух блоков.

Если указаны два используемых блока, то нужно организовать их swap таким образом, чтобы при внезапном завершении
иметь возможность вернуться к состоянию до или после операции.

Примерно то же должно происходить при ситуации "один свободный, один используемый", только здесь помягче требования
к содержимому свободного. Можно делать просто копирование, а не swap. Ну и в плане атомерности можно не переживать за содержимое свободного блока (а вот зв статус свободного переживать надо).

Если `log-file` не существует, это означает, что наш `device-file` в целостном состоянии, можно исполнять `actions-file`.

Если `log-file` существует, то гарантируется, что никто, кроме вашего приложения, в него не писал.

При старте вы должны по его содержимому понять, не было ли аварийного завершения и если оно было, то выполнить действия для 
поддержания атомарности.

Будем считать, что атомарность записей в сам `log-file` гарантируется. А атомарность действий по восстановлению атомерности - нет.

То есть можно полагать, что `kill -9` не прилетит в момент записи в `log-file`.

Но возможен такой сценарий:

- что-то стряслось во время дефрагментации
- запустили заново
- утилита поняла, что оборвалась невовремя
- утилита пошла восстанавливать атомарность
- пока восстанавливала, снова что-то стряслось

Это может повторяться конечное число раз, и в итоге все должно продолжить работу.

Содержимое файла - на ваше усмотрение.

Выбор схемы логирования - на ваше усмотрение.

Пострайтесь сделать так, чтобы `log-file` не хранил то, что уже точно не пригодится.

Если для этого нужно использовать несколько файлов - это ok. Тогда в командной строке принимайте одно имя
и порождайте другие по какой-то своей схеме.

Можно использовать тот факт, что здесь никогда не будет перекрывающихся атомарных операций.

### Сценарий крупным планом

Крупным планом предполагается, что есть какой-то черный ящик, создающий план дефрагментации.

План дефрагментации - это `actions-file`.

Мы его запускаем с несуществующим `log-file`.

Когда он отработает, мы увидим `DONE` и обрадуемся.

А если кто-то нас внезапно и невовремя прибьет - мы снова запустим ту же командную строку - и оно должно продолжить
работу.
